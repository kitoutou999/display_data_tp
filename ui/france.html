<!DOCTYPE html>

<head>

    <meta charset="utf-8">


    <!-- Load d3.js -->
    <script src="js/d3.v7.min.js"></script>
    <link rel="stylesheet" href="css/colorbrewer.css">
    <link rel="stylesheet" href="css/style.css">

</head>

<body>

    <!-- Create a div where the graph will take place -->
    <div id="map"></div>
    <div id="details"></div>

    <script>

        const width = 700, height = 550;

        // fortement inspiré de https://www.datavis.fr/d3js/map-population
        // documentation à https://github.com/d3/d3-geo

        // le générateur de chemin géographique (geographic path generator) 
        // d3.geoPath est un générateur de forme. Il utilise des données 
        // GeoJSON qu'il transforme en un chemin SVG

        const path = d3.geoPath();

        // un chemin a besoin d'un type de projection qui définit comment 
        // des données sphériques sont représentées en deux dimension.
        // Ici, on utilise la profection conique conforme
        const projection = d3.geoConicConformal() // Lambert-93
            .center([2.454071, 46.279229]) // Center on France
            .scale(2600)
            .translate([width / 2 - 50, height / 2]);

        path.projection(projection);

        // définition du canvas initial
        const svg = d3.select('#map').append("svg")
            .attr("id", "svg")
            .attr("width", width)
            .attr("height", height)
            .attr("class", "Blues");

        // on ajoute un élément "departments"    
        const departments = svg.append("g");

        // on déclare un tableau de promesses qui vont s'enchaîner
        var promises = [];
        promises.push(d3.json('data/departments.json'));
        promises.push(d3.json("http://127.0.0.1:4000/?query={departments{department count}}"));
    
        // lorsque toutes les promesses sont réalisées :
        Promise.all(promises).then(function (values) {
            const geojson = values[0]; // Récupération de la première promesse : le contenu du fichier geoJSON
            console.log("geojson", geojson)
            const dpts = values[1].data.departments; // Récupération de la deuxième promesse : les ventes par département
            console.log("departments", dpts)


            // ajout des chemins de chaque département
            var features = departments
                .selectAll("path")
                .data(geojson.features)
                .enter()
                .append("path")
                .attr('id', d => "d" + d.properties.CODE_DEPT)
                .attr("d", path);

            // définition de la fonction de transformation de valeur vers l'intervalle [0,1]
            var quantile = d3.scaleQuantile()
                .domain([0, d3.max(dpts, e => +e.count)])
                .range(d3.range(9));

            // ajoute d'un élément SVG pour afficher la légende
            var legend = svg.append('g')
                .attr('transform', 'translate(525, 150)')
                .attr('id', 'legend');

            legend.selectAll('.colorbar')
                .data(d3.range(9))
                .enter().append('svg:rect')
                .attr('y', d => d * 20 + 'px')
                .attr('height', '20px')
                .attr('width', '20px')
                .attr('x', '0px')
                .attr("class", d => "q" + d + "-9")

            var legendScale = d3.scaleLinear()
                .domain([0, d3.max(dpts, e => +e.count)])
                .range([0, 9 * 20]);

            var legendAxis = svg.append("g")
                .attr('transform', 'translate(550, 150)')
                .call(d3.axisRight(legendScale).ticks(6));

            const zeroPad = (num, places) => String(num).padStart(places, '0')

            dpts.forEach(function (e, i) {
                d3.select("#d" + zeroPad(e.department, 2))
                    .attr("class", d => "department q" + quantile(+e.count) + "-9")
                    .on("mouseover", function (event, d) {
                        div.transition()
                            .duration(200)
                            .style("opacity", .9);
                        div.html("<b>Département : </b>" + e.department + "<br>"
                            + "<b>Count : </b>" + e.count + "<br>")
                            .style("left", (event.pageX + 30) + "px")
                            .style("top", (event.pageY - 30) + "px");
                    })
                    .on("mouseout", function (event, d) {
                        div.style("opacity", 0);
                        div.html("")
                            .style("left", "-500px")
                            .style("top", "-500px");
                    })
                    .on("click", function(event, d) {                   
                        d3.json(`http://127.0.0.1:4000/?query={prestationsByDpt(departement:"${e.department}"){description count sum avg min max}}`)
                            .then(data => drawPrestation(data, e.department));
                    });
            });
        });
        function drawPrestation(data, department){
            const detailsDiv = d3.select("#details");
            detailsDiv.html(""); 
            detailsDiv.append("h2").html(`Département <span style='color:red'>${department}</span>`);
    
                const prestations = data.data.prestationsByDpt;
                
                const totalCount = d3.sum(prestations, d => d.count);
                const totalRevenue = d3.sum(prestations, d => d.sum);
                const prixMoyen = totalRevenue / totalCount;

                const stats = detailsDiv.append("div")
                    .style("display", "flex")
                    .style("gap", "20px")
                    .style("margin-bottom", "20px");
                
                stats.append("div").html(`<strong>Total Interventions:</strong> ${totalCount}`);
                stats.append("div").html(`<strong>Chiffre d'affaires:</strong> ${totalRevenue.toLocaleString()} €`);
                stats.append("div").html(`<strong>Prix Moyen:</strong> ${prixMoyen.toFixed(2)} €`);

                // Préparation des données (tri et nettoyage)
                const fixedDesc = prestations.map(d => {
                    return {
                        description: d.description.replaceAll("??", "é"),
                        count: d.count,
                        min: d.min,
                        max: d.max,
                        avg: d.avg
                    };
                });
                fixedDesc.sort((a, b) => b.count - a.count);

                const contentDiv = detailsDiv.append("div")
                    .style("display", "flex")
                    .style("align-items", "flex-start");

                const margin = { top: 50, right: 30, bottom: 100, left: 60 },
                    width = 500 - margin.left - margin.right,
                    height = 400 - margin.top - margin.bottom;

                const svg = contentDiv.append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                // Titre
                svg.append("text")
                    .attr("x", (width / 2))             
                    .attr("y", -20)
                    .attr("text-anchor", "middle")  
                    .style("font-size", "16px") 
                    .style("font-weight", "bold")  
                    .text("Répartition des prestations");

                // Axe X
                const x = d3.scaleBand()
                    .range([0, width])
                    .domain(fixedDesc.map(d => d.description))
                    .padding(0.2);

                svg.append("g")
                    .attr("transform", `translate(0, ${height})`)
                    .call(d3.axisBottom(x))
                    .selectAll("text")
                    .attr("transform", "translate(-10,0)rotate(-45)")
                    .style("text-anchor", "end");

                // Axe Y
                const y = d3.scaleLinear()
                    .domain([0, d3.max(fixedDesc, d => d.count)])
                    .range([height, 0]);
                
                svg.append("g")
                    .call(d3.axisLeft(y));

                // Barres
                svg.selectAll("mybar")
                    .data(fixedDesc)
                    .join("rect")
                    .attr("x", d => x(d.description))
                    .attr("y", d => y(d.count))
                    .attr("width", x.bandwidth())
                    .attr("height", d => height - y(d.count))
                    .attr("fill", "#69b3a2")
                    

                
                const listDiv = contentDiv.append("div")
                    .style("margin-left", "20px")
                    .style("padding-top", "40px")
                    .style("max-height", "400px")
                    .style("overflow-y", "auto");

                listDiv.append("h4").text("Détails chiffrés (Prix Min - Max - Moyenne) :");
                const ul = listDiv.append("ul");
                fixedDesc.forEach(d => {
                    ul.append("li").html(`<b>${d.description}</b> : ${d.count} interv.<br>
                    <span style="font-size:0.9em; color:gray">Prix : ${d.min}€ - ${d.max}€ (Moy: ${d.avg ? d.avg.toFixed(2) : 'N/A'}€)</span>`);
                });
        }
        
        

        // Refresh colors on combo selection
        d3.select("select").on("change", function () {
            d3.selectAll("svg").attr("class", this.value);
        });

        // Append a DIV for the tooltip
        var div = d3.select("body").append("div")
            .attr("class", "chart-tooltip")
            .style("opacity", 0);

        
    </script>
</body>